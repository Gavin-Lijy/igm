#!/usr/bin/env python
import warnings
warnings.simplefilter(action='ignore', category=FutureWarning)
import igm
import sys
import atexit
import os, os.path
from shutil import copyfile, SameFileError

# create a file with the process id to monitor it
pid = os.getpid()
with open('.igm-pid.txt', 'w') as f:
    f.write(str(pid))
def rmpid():
    os.remove('.igm-pid.txt')
atexit.register(rmpid)

#===start pipeline with configure file
cfgfile = os.path.abspath(sys.argv[1])
cfg = igm.Config(cfgfile)

igm.SetupLogging(cfg)
igm.logger.info('Starting pipeline. Configuration from ' + cfgfile)

# Preprocess genome, index and allocate disk space for genome structures

igm.Preprocess(cfg)

# Generate random initial configuration

starting_coordinates = cfg.get("model/starting_coordinates")
if starting_coordinates != '':
    igm.logger.info('Initial coordinates from: ' + starting_coordinates)
    try:
        copyfile(starting_coordinates, cfg.get("optimization/structure_output"))
    except SameFileError:
        pass
else:
    igm.logger.info('Generating random initial coordinates.')
    randomStep = igm.RandomInit(cfg)
    randomStep.run()

    relaxStep = igm.RelaxInit(cfg)
    relaxStep.run()

# optimization iteration
opt_iter = 0
# min optimization iterations before proceeding to next theta
# skipped if iter 0 is successful
min_iter = cfg.get("optimization/min_iterations", 5)
# max unsuccessful optimization iterations before stopping
max_iter = cfg.get("optimization/max_iterations", 12)

# main optimization loop
while True:
    cfg["runtime"]["opt_iter"] = opt_iter

    # setup the needed steps for this optimization iteration
    iter_steps = []
    if 'Hi-C' in cfg['restraints']:
        iter_steps.append(igm.ActivationDistanceStep)
        
    if 'FISH' in cfg['restraints']:
        iter_steps.append(igm.FishAssignmentStep)
        
    if 'sprite' in cfg['restraints']:
        iter_steps.append(igm.SpriteAssignmentStep)
        
    if 'DamID' in cfg['restraints']:
        iter_steps.append(igm.DamidActivationDistanceStep)

    # always run a modeling step
    iter_steps.append(igm.ModelingStep)

    # run the required steps
    for StepClass in iter_steps:
        step = StepClass(cfg)
        step.run()

    # check the violations
    if ((opt_iter == 0) or (opt_iter >= min_iter)) and (cfg.get("runtime/violation_score") < cfg.get("optimization/max_violations")):
        # no violations, go to next step or finish
        opt_iter = 0
        if 'Hi-C' in cfg['restraints'] and len( cfg["runtime"]["Hi-C"]["sigma_list"] ) != 0:
            # we are done with this sigma but still have more to go
            del cfg["runtime"]["Hi-C"]["sigma"]
        else:
            # no violations, no more work to do
            igm.logger.info('Pipeline completed')
            break
    else:
        # if there are violations, try to optimize again
        opt_iter += 1
        if max_iter is not None:
            if opt_iter >= max_iter:
                igm.logger.critical('Maximum number of iterations reached (%d)' % max_iter)
                break
        igm.logger.info('iteration # %d' % opt_iter)


