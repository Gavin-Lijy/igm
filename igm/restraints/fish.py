from __future__ import division, print_function

import numpy as np
from numpy.linalg import norm
from .restraint import Restraint
from ..model.forces import HarmonicUpperBound, HarmonicLowerBound
from ..model.particle import Particle

import h5py

# helper functions

def sort_radially(ii, crd):

    """ Sort radial distances of multiploid annotations [k, k + n_hapl], listed in ii """

    ii = np.array(ii)
    dists = [ norm(crd[i]) for i in ii ]    # compute an array of radial distances (from geometric center)
    return ii[np.argsort(dists)]

def sort_pairs_by_distance(ii, jj, crd):

    """ Sort pairwise distances of multiploid annotations [(i, j), (i, j + n_hapl), (i + n_hapl, j), (i + n_hapl, j + n_hapl)], listed in pairs """

    # value depends on genome ploidity
    n_combinations = len(ii)*len(jj)
    dists = np.zeros(n_combinations)
    pairs = np.zeros((n_combinations, 2), dtype = int)
    it = 0     # this is a counter
    for m in ii:
        for n in jj:
            x = crd[m]
            y = crd[n] 
            dists[it] = norm(x - y)    # distance between n and m
            pairs[it, :] = [m, n]
            it += 1

    # return the list of domain pairs accorting to sorted pairwise distances
    return pairs[np.argsort(dists), :]


class Fish(Restraint):

    """
    Object handles FISH restraint: add list of pair forces to append to igm.model.forces
    
    Parameters
    ----------
    fish_assignment_file : h5df - file list generated by the Assignment Step, dictionary consists of:
		           {'probes',  'radial_min', 'radial_max'         (radial distances, one body)
		             'pairs',    'pair_min',   'pair_max'}        (pairwise distances, two body)
    struct_id : index of structure in population
    index:      alabtools Index object (go from haploid to multiploid annotations)
    rtype:      string, 'r' or 'R' (RADIAL), 'p' or 'P' (PAIR), and combinations
    tol:        tolerance parameter to impose distances
    k:          FISH restraining constant
    
    Read in a fish_file generated from the AssignmentStep, from haploid to diploid annotations, select min or max pair (probe), apply restraints
    """
    
    def __init__(self, 
                 fish_assignment_file,
                 index, 
                 struct_id,
                 rtype,
                 tol=0.0, 
                 k=1.0):
        
        self.fish_assignment_file = fish_assignment_file

        self.rtype     = rtype
        self.index     = index
        self.struct_id = struct_id
        self.tol       = tol
        self.k         = k
        self.forceID   = []

   
        
    def _apply(self, model):
        
        # copy index, includes the diploid annotations
        copy_index = self.index.copy_index

        hff = h5py.File(self.fish_assignment_file, 'r')

        minradial = 'r' in self.rtype    # minimal radial distance (particle to center)
        maxradial = 'R' in self.rtype    # maximal radial distance (particle to center)
        minpair   = 'p' in self.rtype      # minimal pairwise distance (particle to particle)
        maxpair   = 'P' in self.rtype      # maximal pairwise distance (particle to particle)

        struct_id = self.struct_id

        ck        = self.k
        tol       = self.tol
        crd       = model.getCoordinates()     # IGM model, this is where coordinates are directly processed
                                               # only coordinates associated with structure "struct_id" are read in 

        # if we use radial restraint we want to define the center, let's add a DUMMY particle
        if minradial or maxradial:
            center = model.addParticle([0., 0., 0.], 0., Particle.DUMMY_STATIC)

        if minradial:

            probes  = hff['probes']
            targets = hff['radial_min'][:, struct_id]   # select only those "target_distance"s pertaining such a structure
   
            for q, i in enumerate(probes):
                
                # get all the copies of locus i
                ii = copy_index[i]  
                target_dist = targets[q]

                # find the one locus being closest to the center
                particle = sort_radially(ii, crd)[0]

                # add a lower bound on that bead
                f = HarmonicLowerBound((center, particle), 
                                       k=ck,
                                       d=max(0, target_dist - tol),    # is the target_dist very close to the tolerance?
                                       note=Restraint.FISH_RADIAL)
                f = model.addForce(f)
                self.forceID.append(f)

                # add a upper bound on that bead
                f = HarmonicUpperBound((center, particle), 
                                       k=ck,
                                       d=target_dist + tol,
                                       note=Restraint.FISH_RADIAL)
                f = model.addForce(f)
                self.forceID.append(f)

        if maxradial:
            probes  = hff['probes']
            targets = hff['radial_max'][:, struct_id]

            for q, i in enumerate(probes):
                # get all multiploid copies of locus i
                ii = copy_index[i]
                target_dist = targets[q]

                # find the one locus being farthest away from the center
                particle = sort_radially(ii, crd)[-1]

                # add a lower bound on that bead
                f = HarmonicLowerBound((center, particle), 
                                       k=ck,
                                       d=max(0, target_dist - tol),
                                       note=Restraint.FISH_RADIAL)
                f = model.addForce(f)
                self.forceID.append(f)

                # add a upper bound on that bead
                f = HarmonicUpperBound((center, particle), 
                                       k=ck,
                                       d=target_dist + tol,
                                       note=Restraint.FISH_RADIAL)
                f = model.addForce(f)
                self.forceID.append(f)

        if minpair:
            pairs   = hff['pairs']
            targets = hff['pair_min'][:, struct_id]

            for q, (i, j) in enumerate(pairs):
                assert (i != j)

                target_dist = targets[q]

                # get annotations from  all the copies
                ii = copy_index[i]
                jj = copy_index[j]

                # sort all the possible multiploid pairs by distance
                sorted_pairs = sort_pairs_by_distance(ii, jj, crd)
                
                # restraint all the pairs not to be too close

                for m, n in sorted_pairs:    
                    f = HarmonicLowerBound((m, n), 
                                           k=ck,
                                           d=min(0, target_dist - tol),
                                           note=Restraint.FISH_PAIR)
                    f = model.addForce(f)
                    self.forceID.append(f)
            

                # find the closest pair and keep it from getting
                # too far apart

                m, n = sorted_pairs[0]
                f = HarmonicUpperBound((m, n), 
                                       k=ck,
                                       d=target_dist + tol,
                                       note=Restraint.FISH_PAIR)
                f = model.addForce(f)
                self.forceID.append(f)
                
        if maxpair:

            pairs   = hff['pairs']
            targets = hff['pair_max'][:, struct_id]

            for q, (i, j) in enumerate(pairs):
                
                assert (i != j)
                target_dist = targets[q]

                # get annotations from all the copies
                ii = copy_index[i]
                jj = copy_index[j]

                # sort all the possible multiploid pairs by distance
                sorted_pairs = sort_pairs_by_distance(ii, jj, crd)
                
                # restraint all the pairs not to be too far: upper bound, with ck elastic constant, rest length within "tol" tolerance
                for m, n in sorted_pairs:    
                    f = HarmonicUpperBound((m, n), 
                                           k=ck,
                                           d=target_dist + tol,
                                           note=Restraint.FISH_PAIR)
                    f = model.addForce(f)
                    self.forceID.append(f)
            

                # find the furthest pair and keep it from getting
                # too close (look into this)
                m, n = sorted_pairs[0]
                f = HarmonicLowerBound((m, n), 
                                       k=ck,
                                       d=min(0, target_dist - tol),
                                       note=Restraint.FISH_PAIR)
                f = model.addForce(f)
                self.forceID.append(f)

        # close input file and get ready for next iteration
        hff.close()
    
    
#==
